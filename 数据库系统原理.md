[toc]

### 第一章 绪论

DBMS（Database Management System）：包含数据的集合、程序的集合

数据库层次结构：

物理层：存储数据

逻辑层：描述数据以及数据之间的关系

视图层：起到对一些数据的隐藏的作用

 <img src="../../../Desktop/数据库系统原理.assets/截屏2020-12-04 下午6.43.45.png" alt="截屏2020-12-04 下午6.43.45" style="zoom:33%;" />

Schema（模式）：

​	物理模式：数据的物理存储形式的设计（以什么文件形式、文件内的物理块如何构成、块内的形式等）

​	逻辑模式：是针对应用而言的，从具体的应用层次上探讨数据库的设计

Instance（实例）：在某一特定时间点的数据库内容

> 类似程序设计中变量和变量值

物理数据的独立性：只从逻辑上设计数据库，不考虑具体的存储方案

数据模型：一套用于描述数据、数据间的联系、数据的含义/语义、数据约束的工具

关系模型

实体-关系模型

基于对象的数据模型

XML（半结构化数据模型）

网状模型

层次模型

DML分类：

​	过程化的

​	描述性的

数据库用户：

​	应用程序开发者：使用DML交互

​	熟练的用户：数据查询语言

​	特殊的用户

​	初级用户



### 第二章 关系模型

#### 2.1 关系模型

 <img src="../../../Desktop/数据库系统原理.assets/截屏2020-12-04 下午7.34.12.png" alt="截屏2020-12-04 下午7.34.12" style="zoom:33%;" />

属性 ：

关系的每一个属性都有名字

每一个属性都应有取值范围

属性的取值应该是原子的（不可分）

NULL：空值 每一个域中都包含 允许参与运算

​			表示的两种含义：未知、不存在

用大写表示关系模式，小写表示属性

 <img src="../../../Desktop/数据库系统原理.assets/截屏2020-12-04 下午8.10.25.png" alt="截屏2020-12-04 下午8.10.25" style="zoom:33%;" />

键/码

超码：取值各不相同，可以唯一区分元组

候选码：所有超码中属性最少的

主码：从候选码中挑选：挑选始终不变或很少改变的

主码的作用：保障关系模式的定义要求（为了不出现相同的元组，DBMS需要进行比较，为了缩短比较时间，选取最短的（属性最少的）候选码作为主码进行比较）

> 可以不定义主码的情况：使用关系模式中所有的属性定义主码，此时是否定义主码已经不能改DBMS带来好处

外键：一个关系模式中的某些属性刚好是另外一个关系模式的主码，则将其称为外键

外键的作用：起到约束的作用（此关系模式中该属性的取值只能够取与外键相关的关系模式中能够取到的主码值）

 <img src="../../../Desktop/数据库系统原理.assets/截屏2020-12-04 下午8.18.00.png" alt="截屏2020-12-04 下午8.18.00" style="zoom:33%;" />

#### 2.2 关系代数

关系代数语言是过程化的

关系代数、元组关系演算、域关系演算不能在计算机上执行，起到的是过渡作用

六个基本运算：

​	选择：

​		$\sigma_p(r)$ r是关系，p是断言，即关系r中满足条件p的所有元组的集合。其中p允许关系运算$=,\neq,>,\geq,<,\leq$、逻辑运算$\or,\and,!$等

​	<img src="../../../Desktop/数据库系统原理.assets/截屏2020-12-04 下午8.36.57.png" alt="截屏2020-12-04 下午8.36.57" style="zoom:25%;" />

​	投影：$\Pi_{A_1,A_2,...,A_k(r)}$ 即针对关系r，只列出属性$A_1...A_k$

 	<img src="../../../Desktop/数据库系统原理.assets/截屏2020-12-04 下午8.39.43.png" alt="截屏2020-12-04 下午8.39.43" style="zoom:25%;" />

​	投影后可能会有重复项，被删掉

 	<img src="数据库系统原理.assets/截屏2020-12-04 下午8.42.52.png" alt="截屏2020-12-04 下午8.42.52" style="zoom:25%;" />

​	

​	集合的并集：$ r\or s=\{t|t\in r\ or\ t\in s\}$    r和s应相容：属性个数相同、值域相同

​	<img src="数据库系统原理.assets/截屏2020-12-04 下午8.53.30.png" alt="截屏2020-12-04 下午8.53.30" style="zoom:25%;" />

​	集合的差集：$r-s=\{t|t\in r\ and\ t\notin s\}$ r和s应该相容

​	<img src="数据库系统原理.assets/截屏2020-12-04 下午8.55.16.png" alt="截屏2020-12-04 下午8.55.16" style="zoom:25%;" />

​	笛卡尔积：$r\ X s = \{tq|t\in r \ and\ q\in s\}$,假设r和s没有共同的属性

​	<img src="数据库系统原理.assets/截屏2020-12-07 下午4.25.12.png" alt="截屏2020-12-07 下午4.25.12" style="zoom:33%;" />

​	<img src="数据库系统原理.assets/截屏2020-12-07 下午4.25.54.png" alt="截屏2020-12-07 下午4.25.54" style="zoom:33%;" />

​	换名：$\rho_x(E)$将E名字换为x；$\rho_{x(A_1,A_2,...,A_3)}(E)$将E名字换为x且将其中的属性更换为A_1...A_n；解决关系模式间的属性重名问题或同一个关系模式出现在一个表达式中

<img src="数据库系统原理.assets/截屏2020-12-07 下午4.33.53.png" alt="截屏2020-12-07 下午4.33.53" style="zoom:50%;" />	<img src="数据库系统原理.assets/截屏2020-12-07 下午4.32.00.png" alt="截屏2020-12-07 下午4.32.00" style="zoom: 50%;" /><img src="数据库系统原理.assets/截屏2020-12-07 下午4.35.38.png" alt="截屏2020-12-07 下午4.35.38" style="zoom:50%;" />



#### 2.3 附加的关系代数操作

六种基本运算是完备的，附加的运算操作只是使操作更简单

交集：$r\and s=r-(r-s),r\and s=\{t|t\in r \ and\ t\in s\}$

自然链接：$r⋈s$，针对r和s的自然链接，假设r和s有公共的属性，则在 自然链接中要使这些属性相等的进行自然链接

<img src="数据库系统原理.assets/截屏2020-12-07 下午4.48.26.png" alt="截屏2020-12-07 下午4.48.26" style="zoom: 50%;" />	

商集：是一种划分：R中属性包含S中属性，得到的是不包含S属性的元组，即选择出满足S中所有B_i属性的A_i

<img src="数据库系统原理.assets/截屏2020-12-14 下午3.41.06.png" alt="截屏2020-12-14 下午3.41.06" style="zoom:33%;" /> 

 <img src="数据库系统原理.assets/截屏2020-12-14 下午3.42.51.png" alt="截屏2020-12-14 下午3.42.51" style="zoom:33%;" />

<img src="数据库系统原理.assets/截屏2020-12-14 下午3.48.42.png" alt="截屏2020-12-14 下午3.48.42" style="zoom:33%;" /><img src="数据库系统原理.assets/截屏2020-12-14 下午3.49.00.png" alt="截屏2020-12-14 下午3.49.00" style="zoom:33%;" /> <img src="数据库系统原理.assets/截屏2020-12-14 下午3.49.46.png" alt="截屏2020-12-14 下午3.49.46" style="zoom:33%;" />

赋值(<-)：

 <img src="数据库系统原理.assets/截屏2020-12-14 下午3.50.33.png" alt="截屏2020-12-14 下午3.50.33" style="zoom:33%;" />

> 当写的表达式比较长时，通过赋值来使表达式更简洁

 <img src="数据库系统原理.assets/截屏2020-12-14 下午3.52.49.png" alt="截屏2020-12-14 下午3.52.49" style="zoom:33%;" />

#### 2.4 关系模型

一般投影：$\Pi_{F_1,F_2,...,F_n}(R)$ F为算数表达式，如$\Pi_{customer\_name,limit-credit\_balance}(credit\_Info)$ 

avg：average value

min：minimum value

max：maximum value

sum：sum of values

count：number of values

$_{G1,G2,...,Gn}g_{F1(A1),...}(E)$   G1--Gn为分组的条件，F1--Fn为分组后计算的结果

 <img src="数据库系统原理.assets/截屏2020-12-14 下午4.08.49.png" alt="截屏2020-12-14 下午4.08.49" style="zoom:33%;" /><img src="数据库系统原理.assets/截屏2020-12-14 下午4.10.18.png" alt="截屏2020-12-14 下午4.10.18" style="zoom:33%;" />

外连接：自然链接会丢失一些公共属性不一致的信息，但外连接可以保存下来

左外连接：不论左侧元组可否与右边元组进行自然链接，都会保存下来

 <img src="数据库系统原理.assets/截屏2020-12-14 下午4.14.35.png" alt="截屏2020-12-14 下午4.14.35" style="zoom:33%;" /><img src="数据库系统原理.assets/截屏2020-12-14 下午4.16.09.png" alt="截屏2020-12-14 下午4.16.09" style="zoom:33%;" />

删除：R <- R-E，如$account\ <-\ account-\sigma_{branch\_name='Perryridge'}(account)$

插入：将要增加的并上原来的，赋值给原关系

更新（update）：可通过投影实现

 <img src="数据库系统原理.assets/截屏2020-12-14 下午4.33.09.png" alt="截屏2020-12-14 下午4.33.09" style="zoom:33%;" />



### 第三章 结构化查询语言SQL

#### 3.1 SQL

数据定义语言：包括关系模型的构建、设计属性的数据类型、相应的约束条件、对于每一个关系的索引、安全性 、授权、物理存储等

#### 3.2 数据类型

char(n)：最大长度为n，实际长度小于n则填充，大于n则截断

varchar(n)：最大长度为n，实际长度小于n则按实际长度存储，即不填充

> 定长字符串的查询效率最高
>
> 长度比较长的字符串用变长字符串（长度变化较大），较短的用定长字符串

numeric(p,d)：p表示数字长度，包含整数部分和小数部分；d表示小数点后保留的位数

table（表）：

$Create\ Table\ TableName\ (AttributeName_1\ AttributeType_1,...,(constraint_1),...)$

 <img src="数据库系统原理.assets/截屏2020-12-15 下午8.24.35.png" alt="截屏2020-12-15 下午8.24.35" style="zoom:50%;" />

> replace：可以替换现有对象，但现有对象中的数据会丢失，因此标准SQL中不支持replace

 <img src="数据库系统原理.assets/截屏2020-12-15 下午8.29.48.png" alt="截屏2020-12-15 下午8.29.48" style="zoom:50%;" />

常见的约束条件：

not null：非空

primary key (A1,...,An)：主键为一个属性或多个属性列的组合，定义primary key的属性不再需要定义not null和unique

 <img src="数据库系统原理.assets/截屏2020-12-15 下午8.32.06.png" alt="截屏2020-12-15 下午8.32.06" style="zoom:50%;" />

#### 3.3 删除和修改

删除：Drop table tableName

修改：

​	1.修改列：增加属性：$alter\ table\ tableName\ add\ A\ D$

​					   删除属性：$alter\ table\ tableName\ drop\ A$

​					   修改属性的数据类型：$alter\ table\ tableName\ modify\ A\ newD$

#### 3.4 基本查询结构

select A_1,A_2,...,A_n

from r_1,r_2,...,r_m

where P

A_i：属性

r_i：关系

P：条件

对应于关系代数：$\Pi_{A_1,A_2,...,A_n}(\sigma_P(r_1* r_2*...*r_m))$

> SQL中不存在自然链接，用等值链接来表示，因此条件P中必须包含r_1,...,r_m之间的等值条件

**select**：对应广义投影

> select和from是必需的，where不是必要的
>
> 除字符串外，SQL语句不区分大小写

关键字：

1.distinct：删去结果中的重复元素

 <img src="数据库系统原理.assets/截屏2020-12-16 上午9.17.18.png" alt="截屏2020-12-16 上午9.17.18" style="zoom:50%;" />

2.all：保留重复

> select默认保留重复

3.*：查询所有属性

 <img src="数据库系统原理.assets/截屏2020-12-16 上午9.18.46.png" alt="截屏2020-12-16 上午9.18.46" style="zoom:50%;" />

4.广义投影：

 <img src="数据库系统原理.assets/截屏2020-12-16 上午9.20.35.png" alt="截屏2020-12-16 上午9.20.35" style="zoom:50%;" />

**where**：增加查询的条件：> < = between...and...

<img src="数据库系统原理.assets/截屏2020-12-16 上午9.32.02.png" alt="截屏2020-12-16 上午9.32.02" style="zoom:50%;" /> <img src="数据库系统原理.assets/截屏2020-12-16 上午9.30.41.png" alt="截屏2020-12-16 上午9.30.41" style="zoom:50%;" />

**from**：from后的多个表做笛卡尔乘积，因此当表较多时要加where，一般来说，当from后有n个表时where后至少有n-1个等值链接条件

#### 3.5 重命名

oldName as newName

> as可省略
>
> 是显示结果的属性名改变，并不改变原表中的属性名

 <img src="数据库系统原理.assets/截屏2020-12-16 上午9.38.05.png" alt="截屏2020-12-16 上午9.38.05" style="zoom:50%;" />

from子句后使用as，实际上是在内存空间中将表复制

 <img src="数据库系统原理.assets/截屏2020-12-16 上午9.39.17.png" alt="截屏2020-12-16 上午9.39.17" style="zoom:50%;" />

字符串操作

%：可以匹配任意长度（0或多个）的字串

_：匹配任意一个字符

采用like关键字说明

 <img src="数据库系统原理.assets/截屏2020-12-16 上午9.47.43.png" alt="截屏2020-12-16 上午9.47.43" style="zoom:50%;" />

转义字符：可自定义

$like\ \  'Main \# \%'\ \ escape\ \ ' \# '$

连接符号 ｜｜

string1||string2

#### 3.6 排序

order by：按字母序排序

desc：降序排列

asc：升序排列（默认）

order by ... asc/desc

> 排序需要额外占用存储空间
>
> 排序需要一定时间
>
> 对中间结果查询对查询无用，因此规定order by要放在select子句的末尾
>
> 尽可能缩小结果集，节省空间

 <img src="数据库系统原理.assets/截屏2020-12-16 上午9.58.35.png" alt="截屏2020-12-16 上午9.58.35" style="zoom:50%;" />

集合运算：

查询结果可能是多重集，即可能会出现两个元组完全相同的情况

并集：union all

交集：intersect all

差集：except all

参与运算的两个集合的结构应相同或相容（属性个数相同，属性类型相同或相容）

 <img src="数据库系统原理.assets/截屏2020-12-16 上午10.12.01.png" alt="截屏2020-12-16 上午10.12.01" style="zoom:50%;" />

> 加all表示选取所用，不加表示选出的值不重复

#### 3.7 聚集函数

avg：average value

 <img src="../../../Library/Application Support/typora-user-images/截屏2020-12-16 上午10.17.13.png" alt="截屏2020-12-16 上午10.17.13" style="zoom:50%;" />

min：minimum value

max：maximum value

sum：sum of values

count：number of values

 <img src="数据库系统原理.assets/截屏2020-12-16 上午10.18.44.png" alt="截屏2020-12-16 上午10.18.44" style="zoom:50%;" />

> count(*)按整行计数，即该行存在即可，忽略其中为空的属性，如果按某一属性进行计数或求和或取平均时，若某行属性为空，则被忽略，不计数不加和等

 <img src="数据库系统原理.assets/截屏2020-12-16 上午10.23.52.png" alt="截屏2020-12-16 上午10.23.52" style="zoom:50%;" />

group by：按某字段分组，通常与聚集函数一起使用

> select子句中，所有出现在select子句中的自然属性的列必须出现在group by子句中

having：对计算后的中间结果或者自然属性进行条件判断；where对自然属性进行判断，不可以对中间结果进行条件判断

where在group by之前进行判断

where可以减少group by的元组数，提高效率

having在group by后进行判断

 <img src="数据库系统原理.assets/截屏2020-12-16 上午10.50.42.png" alt="截屏2020-12-16 上午10.50.42" style="zoom:50%;" />

#### 3.8 空值

is null / is not null：判断某一属性值是否为空

null参与算数运算结果为null

聚集函数的操作会忽略空值

逻辑运算：null既不是true，也不是false，属于第三值

与null进行比较运算结果为null

null 参与逻辑运算：

unknown or true = true

unknown or false = unknown

unknown or unknown = unknown

unknown and true = unknown

unknown and false = false

unknown and unknown = unknown

not unknown = unknown

在操作中，unknown当false处理



#### 3.9嵌套子查询

 <img src="数据库系统原理.assets/截屏2020-12-16 下午9.53.05.png" alt="截屏2020-12-16 下午9.53.05" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-16 下午9.55.30.png" alt="截屏2020-12-16 下午9.55.30" style="zoom:50%;" />

元组变量的使用：

 <img src="数据库系统原理.assets/截屏2020-12-16 下午9.59.48.png" alt="截屏2020-12-16 下午9.59.48" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-16 下午9.59.29.png" alt="截屏2020-12-16 下午9.59.29" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-16 下午10.01.26.png" alt="截屏2020-12-16 下午10.01.26" style="zoom:50%;" />

some关键字：和集合中某一个或多个相比较，只要有一个符合即为true

 <img src="数据库系统原理.assets/截屏2020-12-16 下午10.03.24.png" alt="截屏2020-12-16 下午10.03.24" style="zoom:50%;" />

all关键字：和集合中所有的值进行比较

#### 3.10 空关系测试

exists/not exists：判断子查询返回的是否是空集合

 <img src="数据库系统原理.assets/截屏2020-12-16 下午10.15.39.png" alt="截屏2020-12-16 下午10.15.39" style="zoom:50%;" />

```sql
select distinct S.customer_name
	from depositor as S
	where not exists(
  (select branch_name
  from branch
  where branch_city='Brooklyn')    --查询Brooklyn的所有支行，得到集合1
  except                           --在集合1中不在集合2中的元素组成的集合，若该集合为空，即当not exists为真时，集合1包含于集合二，则说明S中此行是符合要求的
  (select R.branch_name
  from
  depositer as T,account as R      
  where
  T.account_number=
  R.account_number and
  S.customer_name=
  T.customer_name))                
  --等值链接，将支行和账户关联起来，得到集合2，此处S.customer_name为S中的每个元素，集合1和集合2均是对S中一行进行判断时产生的
  --涉及到两个depositor表S、T和一个account表R
  
```

unique：判断子查询返回的集合是否是唯一的，即集合在你是否无重复元组，无重复则为true

#### 3.11 导出关系

在from中加入子查询，建立新的关系（导出关系）

对外层来说查询已经完成，不是中间结果，使用where不用having

 <img src="数据库系统原理.assets/截屏2020-12-17 上午8.51.00.png" alt="截屏2020-12-17 上午8.51.00" style="zoom:50%;" />

with关键字：将要用的子查询提前执行；简化复杂查询

 <img src="数据库系统原理.assets/截屏2020-12-17 上午8.54.11.png" alt="截屏2020-12-17 上午8.54.11" style="zoom:50%;" /><img src="数据库系统原理.assets/截屏2020-12-17 上午8.56.37.png" alt="截屏2020-12-17 上午8.56.37" style="zoom:50%;" />



#### 3.12查询

Update：用于数据修改

$update\ tableName\ set...$

 <img src="数据库系统原理.assets/截屏2020-12-17 上午9.03.56.png" alt="截屏2020-12-17 上午9.03.56" style="zoom:50%;" />

> 此更新中两条语句先后顺序不可改变，否则小于10000的涨息后可能超过10000，参加下一次更新
>
> 注：update后面的表只能是一个；如果在条件中涉及到其他表的值，在where中使用子查询

case语句：

 <img src="数据库系统原理.assets/截屏2020-12-17 上午9.09.10.png" alt="截屏2020-12-17 上午9.09.10" style="zoom:50%;" />

Delete：删除表或删除表某一项

$delete\ from\ tableName$

$delete\ from\ tableName\ where...$

 <img src="数据库系统原理.assets/截屏2020-12-17 上午9.21.01.png" alt="截屏2020-12-17 上午9.21.01" style="zoom:50%;" />

> delete只能对一个表进行操作

#### 3.13 视图

视图也称虚表，在存储中不存储数据，存储的实际上是一个查询语句，查询视图时，执行查询语句，得到一个导出关系

视图的定义：

$create\ view\ as\ <query\ expression>$

 <img src="数据库系统原理.assets/截屏2020-12-17 上午9.45.56.png" alt="截屏2020-12-17 上午9.45.56" style="zoom:50%;" />

> 视图可以创建在视图上，即视图2的创建中直接使用了视图1，则视图2是 依赖视图1的

#### 3.14 更新视图

如果视图是可更新的：使用方式和表一致

 <img src="数据库系统原理.assets/截屏2020-12-17 下午2.59.19.png" alt="截屏2020-12-17 下午2.59.19" style="zoom:50%;" />

视图本身不存储数据，只是一个查询语句，因此对视图的更新操作最终会转化为对基本表的更新，其中未给值的属性值为null

二义性：

涉及多个表或者主键未给值

 <img src="数据库系统原理.assets/截屏2020-12-17 下午3.02.18.png" alt="截屏2020-12-17 下午3.02.18" style="zoom:50%;" />

可以被更新的视图：

基于一个表（即单表视图）；视图要包含主键；不包含聚集函数

#### 3.15 视图扩展操作

插入操作：$insert\ into\ table(view)Name(A_1,A_2,...,A_n)\ values\ (...)$

> 属性名可省，此时默认对所有属性均赋值且按顺序赋值
>
> 一次只能插入一条数据
>
> 属性值为null时，可以省略为一个空格如$,null, 与, ,相同$

一次性插入多条语句：根据已有结果集对其他表进行插入

 <img src="数据库系统原理.assets/截屏2020-12-17 下午3.16.57.png" alt="截屏2020-12-17 下午3.16.57" style="zoom:50%;" />

#### 3.16 链接关系（选讲）

 <img src="数据库系统原理.assets/截屏2020-12-17 下午3.34.36.png" alt="截屏2020-12-17 下午3.34.36" style="zoom:50%;" />

inner join

 <img src="数据库系统原理.assets/截屏2020-12-17 下午3.24.44.png" alt="截屏2020-12-17 下午3.24.44" style="zoom:50%;" />

left outer join

 <img src="数据库系统原理.assets/截屏2020-12-17 下午3.25.02.png" alt="截屏2020-12-17 下午3.25.02" style="zoom:50%;" />

right outer join

 <img src="数据库系统原理.assets/截屏2020-12-17 下午3.26.07.png" alt="截屏2020-12-17 下午3.26.07" style="zoom:50%;" />

full outer join

 <img src="数据库系统原理.assets/截屏2020-12-17 下午3.31.48.png" alt="截屏2020-12-17 下午3.31.48" style="zoom:50%;" />

令using中的属性对应相等

natural join中对同名属性相等的进行链接，且同名属性只保留一列



### 第四章 中级SQL

#### 4.1 内建数据类型

date：年月日时分秒

不同的数据库产品，日期的表示不一定相同

 <img src="数据库系统原理.assets/截屏2020-12-17 下午10.06.08.png" alt="截屏2020-12-17 下午10.06.08" style="zoom:50%;" />

interval：时间间隔；相对时间，是两个时间的时间差

用户自定义类型：$create\ type\ typeName\ as\ ...$

 <img src="数据库系统原理.assets/截屏2020-12-17 下午10.13.19.png" alt="截屏2020-12-17 下午10.13.19" style="zoom:50%;" />

final：不可再根据此类型创建其他类型

自定义域：$create\ domain\ ...$

 <img src="数据库系统原理.assets/截屏2020-12-17 下午10.13.59.png" alt="截屏2020-12-17 下午10.13.59" style="zoom:50%;" />

域是可以有约束的，数据类型不含约束

 <img src="数据库系统原理.assets/截屏2020-12-17 下午10.16.02.png" alt="截屏2020-12-17 下午10.16.02" style="zoom:50%;" />

尽管实际上是一样的，但是是不同的数据类型，不可以直接赋值，要进行强制的类型转换

大对象类型：存储媒体文件

blob：存储二进制对象：图片、文件等

clob：按字符存储，文本大对象，储存纯文本



#### 4.2 完整性约束

用于保障数据一致性

常用的约束：

1.非空约束not null

$attributeName\ attributeType\ not\ null$

$create\ domain\ domainName\ domainType\ not\ null$

2.唯一性约束unique

$unique(A_1,...,A_m)$表示这些属性的值的组合是唯一的，即可作为一个候选码

加唯一性约束的属性列可以为空

3.check

$check(P)$    P为表达式

 <img src="数据库系统原理.assets/截屏2020-12-17 下午10.42.45.png" alt="截屏2020-12-17 下午10.42.45" style="zoom:50%;" />

> primary key约束：非空、唯一、在底层创建索引
>
> check也可以用在domain定义中

 <img src="数据库系统原理.assets/截屏2020-12-17 下午10.45.54.png" alt="截屏2020-12-17 下午10.45.54" style="zoom:50%;" />

$constaint conName...$显式对约束定义名字，可通过名字访问该约束；可以省略，省略后数据库会自动生成名字，但是对用户不可见

#### 4.3 参照完整性

多个表之间的约束

primary key：唯一性、非空

unique key：唯一，可为空

一个表中有0或1个primary key，可以有0或多个unique key

foreign key：在两个或多个表之间建立关联，在一个表中创建的外键必须是另一表的主键

 <img src="数据库系统原理.assets/截屏2020-12-18 上午8.43.20.png" alt="截屏2020-12-18 上午8.43.20" style="zoom:50%;" />

> branch表后可以加（branch_name）来明确说明对应关系，也可省略

 <img src="数据库系统原理.assets/截屏2020-12-18 上午8.47.26.png" alt="截屏2020-12-18 上午8.47.26" style="zoom:50%;" />



#### 4.4 断言

保证数据满足一定条件

与check约束的区别：check是基于一个属性的约束，断言可以基于多个表

$create\ assertion\ assertionName\ check...$

在创建断言时，要创建的断言涉及到的已有的数据应满足该断言，否则无法创建（因此最好在投入使用前创建断言）

 <img src="数据库系统原理.assets/截屏2020-12-18 上午8.53.15.png" alt="截屏2020-12-18 上午8.53.15" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-18 上午8.53.32.png" alt="截屏2020-12-18 上午8.53.32" style="zoom:50%;" />

每一次数据更新都会判断一次断言，产生额外的开销

#### 4.5 授权

限定用户的操作权限

常见的数据库权限

Read：相当于select授权

Insert

Update

Delete

Index：允许创建或删除索引

Resources：允许创建新关系

Alteration：允许添加或删除关系中的属性

Drop：允许删除关系

$grant\ privilegeList\ on\ relationOrviewName\ to\ userList$

privilegeList：权限名列表，用逗号分隔；或者为all，表示当前表的所有权限；或者为一个角色（详见第八章）

userList可以是一个用户的id，也可以是public，为public时为所有用户授予当前权限，也可以是一个角色（详见第八章）

SQL中的常用权限：

 <img src="数据库系统原理.assets/截屏2020-12-18 上午9.11.26.png" alt="截屏2020-12-18 上午9.11.26" style="zoom:50%;" />

例：$grant\ select\ on\ branch\ to\ U1,U2,U3$

权限回收：$revoke\ privilegeList\ on\ relationOrviewName\ to\ userList$

#### 4.6 嵌入式SQL

 <img src="数据库系统原理.assets/截屏2020-12-18 上午9.39.06.png" alt="截屏2020-12-18 上午9.39.06" style="zoom:50%;" />

 declare ... cursor for...

定义游标：在内存中分配一块存储区域，存放查询的结果，数据按堆栈结构存储

 $open\ cursorName$此时真正执行，分配存储空间并存入查询结果

$fetch\ cursorName\ into:var1,:var2...$获得结果的一行，将一行中每个属性值赋值给一个变量，指针下移

 $close\ cursorName$关闭游标并归还存储空间

 declare ... cursor for...for update：游标是可更新的，当对游标中的数据更新数据时，也会对相应表中的数据进行更新

#### 4.7 过程和函数

定义：

 <img src="数据库系统原理.assets/截屏2020-12-18 上午9.58.11.png" alt="截屏2020-12-18 上午9.58.11" style="zoom:50%;" />

table functions：可返回一个表变量

 <img src="数据库系统原理.assets/截屏2020-12-18 上午10.01.45.png" alt="截屏2020-12-18 上午10.01.45" style="zoom:50%;" />

使用：

 <img src="数据库系统原理.assets/截屏2020-12-18 上午10.00.57.png" alt="截屏2020-12-18 上午10.00.57" style="zoom:50%;" />

形式上，过程与函数的区别在于无返回值

 <img src="数据库系统原理.assets/截屏2020-12-18 上午10.04.16.png" alt="截屏2020-12-18 上午10.04.16" style="zoom:50%;" />

in类型参数：输入参数

out类型参数：输出参数

过程的out参数可以有多个，因此相当于有多个返回值

in类型在过程调用时必须赋初值，在过程执行中按常量处理

out类型在过程调用时不必赋初值，但在执行中要赋值

函数和过程的重载：名字一致，参数类型不同（最好也要不兼容）或个数不同

#### 4.8 过程化结构

存在于在begin和end之间

 <img src="数据库系统原理.assets/截屏2020-12-18 上午10.13.52.png" alt="截屏2020-12-18 上午10.13.52" style="zoom:50%;" />

default：变量赋初值

语句可以用分号分隔

 <img src="数据库系统原理.assets/截屏2020-12-18 上午10.14.47.png" alt="截屏2020-12-18 上午10.14.47" style="zoom:50%;" /><img src="数据库系统原理.assets/截屏2020-12-18 上午10.16.22.png" alt="截屏2020-12-18 上午10.16.22" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-18 上午10.18.43.png" alt="截屏2020-12-18 上午10.18.43" style="zoom:50%;" />匿名块，只执行一次，加上create function/procedure后定义为命名块，可以多次调用

exit跳出当前循环体、分支、函数、过程、程序等

#### 4.9 动态SQL

 <img src="数据库系统原理.assets/截屏2020-12-18 上午10.22.57.png" alt="截屏2020-12-18 上午10.22.57" style="zoom:50%;" />

> 图中EXEC之前部分为C程序

？：内部变量，值不同结果不同

:account：‘：’表示外部变量，using表示用此外部变量代替内部变量

递归：

  <img src="数据库系统原理.assets/截屏2020-12-18 上午10.27.51.png" alt="截屏2020-12-18 上午10.27.51" style="zoom:50%;" />

例：查询直接或间接的上司

 <img src="数据库系统原理.assets/截屏2020-12-18 上午10.28.22.png" alt="截屏2020-12-18 上午10.28.22" style="zoom:67%;" />

递归查询，不断写入结果集





### 第七章 实体-联系模型关系

#### 7.1 关系数据库设计

 <img src="数据库系统原理.assets/截屏2020-12-18 下午6.42.31.png" alt="截屏2020-12-18 下午6.42.31" style="zoom:50%;" />

#### 7.2 数据模型

##### 7.2.1 建模

实体：是一个区别于其他的对象

实体具有属性

数据库可以认为是一组实体、实体之间的联系集组成的

实体集：一组具有相同属性和类型的实体组成的集合

 <img src="数据库系统原理.assets/截屏2020-12-18 下午8.18.12.png" alt="截屏2020-12-18 下午8.18.12" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-18 下午8.20.40.png" alt="截屏2020-12-18 下午8.20.40" style="zoom:50%;" />

> 即对于表示n个实体集之间关系的联系集，至少有n个属性，分别取自各个实体集
>
> 实体集可以有自己的属性

联系集的度：指的是联系集所联系的实体集数量

##### 7.2.2 属性

 <img src="数据库系统原理.assets/截屏2020-12-18 下午8.55.18.png" alt="截屏2020-12-18 下午8.55.18" style="zoom:50%;" />

domain：域，属性允许的取值范围

attribute types：

从属性是否可以拆分可以分为简单属性和复合属性（例如通讯地址）

从属性取值划分为单值属性（例如姓名）和多值属性（例如电话号码）

派生属性：例如年龄由出生日期和当前日期得到

#### 7.3 ER模型

##### 7.3.1 E-R图

一个矩形代表一个实体集

一个菱形代表一个关系集

线条：连接属性和实体或实体和联系

一个椭圆代表一个属性

复合属性：一个属性上再连接其他的属性

多值属性：双椭圆表示

派生属性：虚线椭圆

主键：椭圆内的属性名加下划线

 <img src="数据库系统原理.assets/截屏2020-12-19 下午3.20.46.png" alt="截屏2020-12-19 下午3.20.46" style="zoom:50%;" /><img src="数据库系统原理.assets/截屏2020-12-19 下午3.23.13.png" alt="截屏2020-12-19 下午3.23.13" style="zoom:50%;" />

角色：

实体内部各个元组之间有联系

 <img src="数据库系统原理.assets/截屏2020-12-19 下午3.24.43.png" alt="截屏2020-12-19 下午3.24.43" style="zoom:50%;" />

> 上图manager、worker即角色

##### 7.3.2 映射基数约束

联系的约束类型：

一对一：

 <img src="数据库系统原理.assets/截屏2020-12-19 下午3.34.34.png" alt="截屏2020-12-19 下午3.34.34" style="zoom:50%;" />

多对一：

 <img src="数据库系统原理.assets/截屏2020-12-19 下午3.36.44.png" alt="截屏2020-12-19 下午3.36.44" style="zoom:50%;" />

一对多：

 <img src="数据库系统原理.assets/截屏2020-12-19 下午3.35.29.png" alt="截屏2020-12-19 下午3.35.29" style="zoom:50%;" />

多对多：

 <img src="数据库系统原理.assets/截屏2020-12-19 下午3.38.08.png" alt="截屏2020-12-19 下午3.38.08" style="zoom:50%;" />

keys：

超码：

一个或多个联合可以唯一确定实体集中一个实体的属性

候选码：

是属性数量最小的超码

主键：选取的一个候选码（一般选取确定之后不改变、使用较多的候选码）

联系集的主键是有参与该联系集的所有实体集的主键合并的结果

#### 7.4 扩展的E_R特征

##### 7.4.1 弱实体集

弱实体集：无主键的实体集，用双矩形表示

在E-R图中所有实体集都不是孤立的

对于弱实体来说，一定会参与到实体集中；凡是与弱实体集有联系的实体集，称为强实体集，组成的关系为**标识性联系**（用双菱形表示）

分辨符：与所依赖的强实体集的主键构成弱实体集的主键，名字下加虚下划线表示

 <img src="数据库系统原理.assets/截屏2020-12-19 下午4.00.57.png" alt="截屏2020-12-19 下午4.00.57" style="zoom:50%;" />

##### 7.4.2 基数约束

从联系到实体：用有向线表示一，无向线表示多

一对一：

 <img src="数据库系统原理.assets/截屏2020-12-19 下午4.30.59.png" alt="截屏2020-12-19 下午4.30.59" style="zoom:50%;" />

一对多：

 <img src="数据库系统原理.assets/截屏2020-12-19 下午4.32.32.png" alt="截屏2020-12-19 下午4.32.32" style="zoom:50%;" />

多对一：

 <img src="数据库系统原理.assets/截屏2020-12-19 下午4.33.35.png" alt="截屏2020-12-19 下午4.33.35" style="zoom:50%;" />

多对多：

 <img src="数据库系统原理.assets/截屏2020-12-19 下午4.34.47.png" alt="截屏2020-12-19 下午4.34.47" style="zoom:50%;" />

##### 7.4.3 实体集在联系集中的参与约束

> 例如不是所有的客户都有贷款，但是所有的贷款必须有对应的客户
>
> 部分参与：客户
>
> 完全参与：贷款

 <img src="数据库系统原理.assets/截屏2020-12-19 下午5.11.51.png" alt="截屏2020-12-19 下午5.11.51" style="zoom:50%;" />

在E-R图中表明部分参与和全部参与

 <img src="数据库系统原理.assets/截屏2020-12-19 下午5.14.00.png" alt="截屏2020-12-19 下午5.14.00" style="zoom:50%;" />

0..*：最少0个，最多任意，图中表示一个客户可有0或多个贷款

1..1：有且只有一项，图中表示一笔贷款有且只有一个客户承担

三元联系：

 <img src="数据库系统原理.assets/截屏2020-12-19 下午5.16.34.png" alt="截屏2020-12-19 下午5.16.34" style="zoom:50%;" />

> 不建议经常使用三元联系，因为会出现二义性问题：
>
> 1.实体集A会唯一地与B、C两个实体集相连接
>
> 2.（A，B）会与C相连接，（A，C）会与B相连接

##### 7.4.4 模式的冗余

当多对一且部分参与（如存款人的贷款情况等），可在“多”的一方用null

复合属性：分别、独立作为实体集属性

多值属性：重新创建一个单独的表，设表E的一个多值属性M，则应创建一个单独的表，属性包含E的主键和M的值

is a问题：如person is a customer，继承问题：

方法1:父类的属性不再写，但是继承主键，减少存储空间开销，但查询麻烦

方法2:包含父类的所有属性，但是空间开销大，一个解决办法是不再定义父类表，将父类表定义为视图，通过获取子

类表的属性来实现

聚集：抽象为实体集，应包含聚集的主键，所有实体集的主键，以及自身描述性的属性

 <img src="数据库系统原理.assets/截屏2020-12-26 下午8.09.46.png" alt="截屏2020-12-26 下午8.09.46" style="zoom:33%;" />

 <img src="数据库系统原理.assets/截屏2020-12-26 下午8.10.06.png" alt="截屏2020-12-26 下午8.10.06" style="zoom:25%;" />



##### 7.4.5 聚集

 <img src="数据库系统原理.assets/截屏2020-12-26 下午8.22.04.png" alt="截屏2020-12-26 下午8.22.04" style="zoom:33%;" /><img src="数据库系统原理.assets/截屏2020-12-26 下午8.22.23.png" alt="截屏2020-12-26 下午8.22.23" style="zoom:40%;" />

> 如果没有使用机器，会出现一定的冗余

 <img src="数据库系统原理.assets/截屏2020-12-26 下午8.23.23.png" alt="截屏2020-12-26 下午8.23.23" style="zoom:30%;" /><img src="数据库系统原理.assets/截屏2020-12-26 下午8.24.31.png" alt="截屏2020-12-26 下午8.24.31" style="zoom:33%;" />

> 无冗余，但是丢失了信息：职工在特定项目中用到的特定的机器

聚集是一种抽象，通过它联系被作为高层实体集 ？？？？

实体集A与B以及它们的联系可被看成实体集，并与另一实体集C发生联系

 <img src="数据库系统原理.assets/截屏2020-12-26 下午8.28.08.png" alt="截屏2020-12-26 下午8.28.08" style="zoom:33%;" />

 <img src="数据库系统原理.assets/截屏2020-12-26 下午8.29.09.png" alt="截屏2020-12-26 下午8.29.09" style="zoom:33%;" /><img src="数据库系统原理.assets/截屏2020-12-26 下午8.29.41.png" alt="截屏2020-12-26 下午8.29.41" style="zoom:33%;" />

聚集和三元联系：

看需求



如项目、雇员和部门之间的关系：一个项目由多个部门**资助**，一个部门资助多个项目，每个资助协议由多个雇员**监督**

单纯的三元关系满足不了描述中的要求，因此可用聚集

 <img src="数据库系统原理.assets/截屏2020-12-26 下午8.36.14.png" alt="截屏2020-12-26 下午8.36.14" style="zoom:33%;" />

#### 7.5 设计方法

##### 7.5.1 设计方法

需要注意的问题：

1.描述对象时，是定义为实体集还是属性

根据需求

如身份证号，在一些数据库中可能只是属性，但是在公安部户籍系统中可能就变成一个实体集

2.一些对象定义为实体集还是联系集

如果本该作为实体集的定义为联系集，可能违反E-R图定义或运行过程中出现问题

例如电商平台：

 <img src="数据库系统原理.assets/截屏2020-12-26 下午8.51.28.png" alt="截屏2020-12-26 下午8.51.28" style="zoom:33%;" />

如果将订单定义为联系集，则对于顾客、产品、代理商均一致的订单，主键无法唯一确定一个元组

对于不确定要定义成联系集还是实体集的，可以先定义为联系集，然后为这个联系集确定他的组件，如果这个组件满足联系集的定义并满足业务需求，那么他就是联系集，否则定义为实体集

3.尽量用二元联系而不是三元联系

4.联系集的属性问题

如果不确定联系集的一些属性，可以先不写，如果后面发现有一些两个实体集发生联系会产生一些结果，那么这个结果就可以作为联系集的属性

7.5.2 二元和非二元联系

当出现三元及以上联系时，将三元联系转换为二元联系，在转换过程中需要遵守一定要求，否则会出现错误

通常情况下，任意非二元联系都可以转化为三元联系：

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.01.19.png" alt="截屏2020-12-26 下午9.01.19" style="zoom:50%;" />转换为<img src="数据库系统原理.assets/截屏2020-12-26 下午9.01.38.png" alt="截屏2020-12-26 下午9.01.38" style="zoom:33%;" />

创建实体集E：原来三元关系中R有的属性E都应该有，此外还需要添加新的属性E_i，作为E的主键；

对R_A来说 ，主键为A、E的主键，以此类推

从而将一个三元联系转化为由四个实体集参与的三个二元联系

三元联系中的约束也要分别对应到三个二元联系中

一个不可行的转换方法：

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.06.43.png" alt="截屏2020-12-26 下午9.06.43" style="zoom:33%;" />

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.07.26.png" alt="截屏2020-12-26 下午9.07.26" style="zoom:33%;" />

R1、R2、R3做自然链接，如果可以还原为R，则说明转化是对的

自然链接不能还原，说明转化错误，原因：有约束丢失

而且上述的转化方法不能方便添加额外的属性，如顾客购买商品时的数量

##### 7.5.3 数据库设计流程

E-R模型向关系模式的转换

实体转换为关系，属性转换为关系的属性，声明主键

复合属性：将复合属性中的每个属性单独作为一个属性

多值属性：对多值属性单独生成表

一对多：

实体集之间：将单方参与的实体的主键作为多方参与实体的属性

同一实体集内部：同上，自引用

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.19.52.png" alt="截屏2020-12-26 下午9.19.52" style="zoom: 33%;" />

多对多：

实体集之间：将联系定义为新的关系，属性为参与双方的码（可再额外加属性），如选课

同一实体集内部：

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.23.15.png" alt="截屏2020-12-26 下午9.23.15" style="zoom: 33%;" />

同样要单独成表

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.24.13.png" alt="截屏2020-12-26 下午9.24.13" style="zoom:33%;" />

一对一：若联系双方均部分参与，则将联系定义为一个新的关系，属性为参与双方的码

若一方全部参与，则将另一方的码作为全部参与一方的属性

弱实体集：所对应的关系的码由弱实体集本身的分辨符再加上所依赖的强实体集的码

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.27.07.png" alt="截屏2020-12-26 下午9.27.07" style="zoom:33%;" />

一般化：高层实体集和低层实体集分别转为表，低层实体集（子类）所对应的关系包括高层实体集（父类）的码

如果一般化是不相交且是全部的，即一个高层实体最多并且只能属于一个低层实体集，则可以不为高层实体集建立关系，低层实体集所对应的关系包括上层实体集的所有属性

聚集：实体集A和B以及它们的联系R被看成实体C，C与另一实体集D构成联系S，则S对应的关系的码由R和D的码构成

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.32.17.png" alt="截屏2020-12-26 下午9.32.17" style="zoom:33%;" />

#### 7.6 设计案例

学校数据库：

教师：教工号、教工名、职称

项目：项目编号、项目名称、项目类型、起始年份、资助额

学生：学号、学生名、年龄、学位

业务逻辑：

​	一个教工可以负责多个项目

​	每个项目只能有一个负责人

​	一个老师可以参与多个项目

​	一个学生只能参与一个项目

​	一个项目可以有多个学生和老师参与

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.39.49.png" alt="截屏2020-12-26 下午9.39.49" style="zoom:33%;" /><img src="数据库系统原理.assets/截屏2020-12-26 下午9.40.08.png" alt="截屏2020-12-26 下午9.40.08" style="zoom:33%;" />

#### 7.7 E-R图中拓展的特性

自顶向下设计（特化）

 <img src="数据库系统原理.assets/截屏2020-12-26 下午9.48.28.png" alt="截屏2020-12-26 下午9.48.28" style="zoom:50%;" />

自底向上设计（一般化）

约束：

​	条件定义

​	用户定义（用户人为划分）

​	不相交：如男性或女性

​	重叠：顾客同时是员工

​	全部参与

​	部分参与



### 第八章 关系数据库设计

#### 8.1 

函数依赖（为主）

R是一个关系模式

$\alpha\subseteq R\ and\ \beta\subseteq R$

alpha和beta都是R中的某一列或某几列

$\alpha->\beta$：

alpha**函数决定**beta在R上成立：当且仅当在R上存在合法的关系实例r（R），在r上存在两个元组t1，t2，如果在alpha上的值相等，则在beta上的值也相等，即$t_1[\alpha]=t_2[\alpha]=>t_1[\beta]=t_2[\beta]$

 <img src="数据库系统原理.assets/截屏2020-12-27 下午3.03.14.png" alt="截屏2020-12-27 下午3.03.14" style="zoom:33%;" />

如果K是R的超码，则K函数决定R

候选码：K函数决定R，且K的任意子集不能决定R

函数依赖的使用：

1.用F表示函数依赖的集合，用F判定当前关系r是否符合F

2.通过观察表来定义函数依赖集合

平凡依赖：一定存在的函数依赖，如果beta是alpha的子集，则alpha一定函数决定beta；自己函数决定自己

闭包：根据现有的函数依赖，可以推出其他所有的函数依赖，形成的集合称为闭包（包含平凡依赖），如$A->B,\ B->C,则可推出A->C$

闭包用$F^+$表示

多值依赖

#### 8.2 关系一般化

##### 8.2.1 BCNF

BCNF（Boyce-Codd Normal Form）范式需要满足的条件：对$F^+$中所有函数依赖$\alpha->\beta$，需要满足以下两个条件之一：

1.该依赖是平凡的

2.alpha是R的超码

如果其中有依赖不满足，则该关系模式不是BCNF

 <img src="数据库系统原理.assets/截屏2020-12-27 下午3.20.49.png" alt="截屏2020-12-27 下午3.20.49" style="zoom:50%;" />

> loan_number可以唯一决定amount，但不能决定customer_id，因此不是BCNF

对于函数依赖的关系模式，如果不是BCNF就会有异常或冗余等问题

对于不属于BCNF的，要进行**无损连接分解**，使其满足BCNF

将一个关系模式分解为两个（设不满足BCNF条件的函数依赖为$\alpha->\beta$）：

1.$\alpha\or\beta$

2.$R-(\beta-\alpha)$

 <img src="数据库系统原理.assets/截屏2020-12-27 下午3.27.46.png" alt="截屏2020-12-27 下午3.27.46" style="zoom:50%;" />

分解要做到**保持依赖**（但分解往往会导致约束丢失）

因此BCNF是不容易达到的，遂放宽了对关系模式的条件——**3NF**

3NF范式需要满足的条件：对$F^+$中所有函数依赖$\alpha->\beta$，需要满足以下三个条件之一：

1.该依赖是平凡的

2.alpha是R的超码

3.$\beta-\alpha$中的每一个属性，都应该被R中的某个候选码（可以是不同的候选码）所包含

> 如果一个关系属于BCNF，则一定属于3NF；如果属于2NF，则一定属于3NF，否则需要分解
>
> 属于BCNF：既没有冗余也没有异常
>
> 属于3NF但不属于BCNF：有冗余但没有异常

##### 8.2.2 一般化的目标

函数依赖中让关系模式至少属于3NF

如果关系模式中存在大量的多值依赖，则BCNF并不是理想的，应该用4NF

> 1NF到3NF涉及函数依赖，4NF到5NF涉及到的是多值依赖

#### 8.3 使用函数依赖理论进行分解

##### 8.3.1 函数依赖理论

函数依赖集合F的闭包：$F^+$

阿姆斯特朗公理：

自反律：$if\ \beta\sube\alpha,\ then\ \alpha->\beta$

传递律：$if\ \alpha->\beta,\ \beta->\gamma,\ then\ \alpha->\gamma$

增广律：$if\ \alpha->\beta,\ then\ \gamma\alpha->\gamma\beta$

 <img src="数据库系统原理.assets/截屏2020-12-27 下午4.02.01.png" alt="截屏2020-12-27 下午4.02.01" style="zoom:50%;" />

例：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午4.02.48.png" alt="截屏2020-12-27 下午4.02.48" style="zoom:50%;" />



定义集合A，B

A：通过阿姆斯特朗公理，从F中导出的函数依赖的集合

B：被F所逻辑蕴含的函数依赖的集合

A等价于B

##### 8.3.2 $F^+$的计算

代码描述：

```swift
令 F^+=F
	repeat
		for each F^+中的函数依赖f
				反复使用自反律和增广律
				将结果加入F^+中
		for each f_1和f_2
				如果f_1和f_2可以使用传递律连接，则将结果加入F^+中
		直到F^+不再变化
```

除阿姆斯特朗公理外，还可以使用以下规则：

1.合并：$if\ \alpha->\beta\ and\ \alpha->\gamma,\ then\ \alpha->\beta\gamma$

2.分解：$if\ \alpha->\beta\gamma,\ then\ \alpha->\beta\ and\ \alpha->\gamma$

3.伪传递：$if\ \alpha->\beta\ and\ \gamma\beta->\delta,\ then\ \alpha\gamma->\delta$

从集合角度理解阿姆斯特朗公理：

自反律：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午4.25.43.png" alt="截屏2020-12-27 下午4.25.43" style="zoom:50%;" />

传递律：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午4.26.40.png" alt="截屏2020-12-27 下午4.26.40" style="zoom:50%;" />

增广律：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午4.27.33.png" alt="截屏2020-12-27 下午4.27.33" style="zoom:50%;" />

求F的闭包开销很大，因此去求属性集的闭包

属性集的闭包：对一个属性$\alpha$，在给定的函数依赖集合F中的闭包

求属性集和闭包的算法：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午4.44.49.png" alt="截屏2020-12-27 下午4.44.49" style="zoom:50%;" />

例：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午4.47.19.png" alt="截屏2020-12-27 下午4.47.19" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-27 下午4.47.46.png" alt="截屏2020-12-27 下午4.47.46" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-27 下午4.48.04.png" alt="截屏2020-12-27 下午4.48.04" style="zoom:50%;" />

> 因为$(AG)^+\supe R$, 所以AG是超码
>
> 又因为A和G的闭包都不能决定R，则AG也是候选码

##### 8.3.3 属性集闭包实例

 <img src="数据库系统原理.assets/截屏2020-12-27 下午5.54.42.png" alt="截屏2020-12-27 下午5.54.42" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-27 下午5.56.06.png" alt="截屏2020-12-27 下午5.56.06" style="zoom:50%;" />

属性集闭包的作用 ：

1.判断该属性是不是超码

2.检查函数依赖是否成立：对于$\alpha->\beta$，求出alpha的闭包，看是否包含beta即可

3.通过属性集的闭包求函数依赖集合的闭包

候选码的计算方法（补充知识）：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午6.02.05.png" alt="截屏2020-12-27 下午6.02.05" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-27 下午6.03.22.png" alt="截屏2020-12-27 下午6.03.22" style="zoom:50%;" />

双部属性可能出现在候选码中

 <img src="数据库系统原理.assets/截屏2020-12-27 下午6.05.07.png" alt="截屏2020-12-27 下午6.05.07" style="zoom:50%;" /><img src="数据库系统原理.assets/截屏2020-12-27 下午6.06.49.png" alt="截屏2020-12-27 下午6.06.49" style="zoom:50%;" />

形式化算法描述：

<img src="数据库系统原理.assets/截屏2020-12-27 下午6.12.46.png" alt="截屏2020-12-27 下午6.12.46" style="zoom:50%;" /> <img src="数据库系统原理.assets/截屏2020-12-27 下午6.12.22.png" alt="截屏2020-12-27 下午6.12.22" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-27 下午6.13.25.png" alt="截屏2020-12-27 下午6.13.25" style="zoom:50%;" />

##### 8.3.4 正则覆盖

函数依赖中的冗余依赖：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午6.16.12.png" alt="截屏2020-12-27 下午6.16.12" style="zoom:50%;" />

> A->C可以推出，没必要再单独加一条

冗余的属性称为无关属性

右端有无关属性：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午6.16.48.png" alt="截屏2020-12-27 下午6.16.48" style="zoom:50%;" />

左端有无关属性：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午6.18.44.png" alt="截屏2020-12-27 下午6.18.44" style="zoom:50%;" />

函数依赖集合F的正则覆盖是等价于F的最小函数依赖集合，无冗余依赖和无关属性

无关属性的定义：

如果$A\in \alpha,\ \alpha->\beta$, 则若A是无关属性，则从alpha中去除A后alpha决定beta仍成立

如果$A\in \beta,\ \alpha->\beta$, 则若A是无关属性，则从beta中去除A后alpha决定beta仍成立

形式化算法：

1.判断左端属性是否无关：

求$\alpha-A$的属性闭包，看是否仍然包含$\beta$，若 包含，则A为无关属性

2.判断右端属性是否无关：

将F中$\alpha->\beta$中beta去除A，称为F'，求alpha在F‘上的属性闭包，如果包含beta，则A为无关属性

 <img src="数据库系统原理.assets/截屏2020-12-27 下午7.19.02.png" alt="截屏2020-12-27 下午7.19.02" style="zoom:50%;" />

正则覆盖：F的正则覆盖Fc是满足如下条件的一个依赖集合：

​	F逻辑蕴含Fc中所有的函数依赖

​	Fc逻辑蕴含F中的所有函数依赖

​	Fc中的函数依赖无无关属性

​	在Fc中，所有函数依赖的左端都是唯一的

正则覆盖的算法：

​	1.对F中形如$\alpha_1->\beta_1,\ \alpha_1->\beta_2$的进行合并，转化为$\alpha_1->\beta_1\beta_2$

​	2.对每个函数依赖删除无关属性和冗余依赖

​	3.再次合并

​	4.....

​	直到F不再变化

正则覆盖的结果不一定是唯一的，与无关属性的判断顺序相关

 <img src="数据库系统原理.assets/截屏2020-12-27 下午7.43.57.png" alt="截屏2020-12-27 下午7.43.57" style="zoom:50%;" />



##### 8.3.5 无损连接分解

无损连接分解：分解后的两个关系模式进行自然链接后仍能还原为原来的R；或满足以下两个条件之一：

1.$R_1\and R_2 -> R_1$

2.$R_1\and R_2 -> R_2$

例：

 <img src="数据库系统原理.assets/截屏2020-12-27 下午9.00.10.png" alt="截屏2020-12-27 下午9.00.10" style="zoom:50%;" />

此外还应要求保持依赖，即在上例中还应满足A->B

 <img src="数据库系统原理.assets/截屏2020-12-27 下午9.02.22.png" alt="截屏2020-12-27 下午9.02.22" style="zoom:50%;" />

此分解中，A->B函数依赖丢失

在分解中，既要保证无损连接，又要保证保持依赖

如何保证保持依赖：

若关系模式R被分解为n个子模式，那么每一个**子模式上的函数依赖的集合**的**并的闭包**应等价于原来的F的闭包(属于NP问题，求解开销大)，因此采用以下方法：

​	检查F中每个函数依赖是否均被保留下来：

​		<img src="数据库系统原理.assets/截屏2020-12-27 下午9.09.30.png" alt="截屏2020-12-27 下午9.09.30" style="zoom:50%;" />

##### 8.3.6 实例

R=(A,B,C)

F={A->B, B->C}

Key={A}

显然不属于BCNF

 <img src="数据库系统原理.assets/截屏2020-12-27 下午9.17.28.png" alt="截屏2020-12-27 下午9.17.28" style="zoom:67%;" />

#### 8.4 分解的算法

##### 8.4.1 BCNF判断

对$F^+$中每个函数依赖$\alpha->\beta$，如果该函数依赖是非平凡的，则求$\alpha$的属性集闭包$\alpha^+$，如果该闭包包含R的所有属性，则alpha是超码

相对简单的算法：直接判断F中的非平凡依赖的左端是否均为超码；如果不是BCNF，则对于分解后的关系模式，需要在$F^+$中判断是否为BCNF而不可以再F中判断

例：

 <img src="数据库系统原理.assets/截屏2020-12-28 上午9.26.02.png" alt="截屏2020-12-28 上午9.26.02" style="zoom:67%;" />

> 对于分解后的R_2，如果在F上考虑，R_2中只有平凡的函数依赖，则满足BCNF，而在F+中，隐含AC->D，而AC不是R_2的超码，不满足BCNF



##### 8.4.2 BCNF判断分解

另一种判断方法：对于$\alpha\sube R_i$，求alpha的属性集闭包，看是否包含R_i的全部属性或除了alpha的全部属性，如果不满足，则分解的关系模式不属于BCNF

 <img src="数据库系统原理.assets/截屏2020-12-28 上午9.37.17.png" alt="截屏2020-12-28 上午9.37.17" style="zoom:50%;" />

> 这种分解是无损连接的，但未必是保持依赖的

例：

 <img src="数据库系统原理.assets/截屏2020-12-28 上午9.41.41.png" alt="截屏2020-12-28 上午9.41.41" style="zoom:67%;" />



##### 8.4.3 BCNF分解实例

 <img src="数据库系统原理.assets/截屏2020-12-28 上午9.56.26.png" alt="截屏2020-12-28 上午9.56.26" style="zoom:50%;" />

显然不是BCNF：任何函数依赖的左端均不包含Key

> Key要通过左部右部等规则求出来

 <img src="数据库系统原理.assets/截屏2020-12-28 上午9.59.40.png" alt="截屏2020-12-28 上午9.59.40" style="zoom:50%;" />

> 先分解为R_1，R_2，再将R_2分解为R_3，R_4

##### 8.4.4 3NF

3NF只保证没有异常，允许存在冗余

3NF的算法可以保证无损连接和保持依赖，但是BCNF的分解不能保证保持依赖

例：

 <img src="数据库系统原理.assets/截屏2020-12-28 上午10.58.20.png" alt="截屏2020-12-28 上午10.58.20" style="zoom:50%;" />

 <img src="数据库系统原理.assets/截屏2020-12-28 上午10.59.13.png" alt="截屏2020-12-28 上午10.59.13" style="zoom:50%;" />

判断是否属于3NF的算法：

​	1.判断F中每个函数依赖的左部是否均为超码

​	2.若左部不为超码，需判断右部是否被某个候选码包含

3NF分解算法：

​	1.计算F的正则覆盖Fc

​	2.考察Fc中每个函数依赖，单独成表，判断生成的子模式中是否包含原来的候选码，若无子模式包含候选码，则需要增加如下的子模式：包含R的任一候选码即可，算法结束；若生成的子模式中有子模式包含某候选码，则不用额外生成，算法结束

如此求得的是分解是保持依赖且无损连接的

##### 8.4.5 BCNF和3NF对比

BCNF的分解是无损的，但是**不保证**保持依赖

3NF的分解是无损的，且保持依赖

BCNF是无异常无冗余的

3NF是无异常允许冗余的

规范化理论是理论上的，在实际（如SQL）中，无相关语法描述函数依赖如果要实现，可以通过断言进行约束（开销大）

### 第九章 应用程序的设计与开发

#### 9.1应用程序的设计与开发

绝大多数数据库用户并不直接使用如SQL一样的查询语言进行数据库操作，而是使用如：Web端的Form表单、图形用户接口、报表生成器、数据分析工具等

后台相关的应用程序有CGI、Java Servlets、JSP、PHP、ASP等

#### 9.2 Web工具

无

#### 9.3 Web服务器

 <img src="数据库系统原理.assets/截屏2020-12-28 下午3.50.58.png" alt="截屏2020-12-28 下午3.50.58" style="zoom:50%;" />

#### 9.4 触发器

是一种运行在数据库端的应用程序，直接使用数据库端的过程化语句以及SQL语句编程

触发器通过相应的事件自动调用

需要注意：触发的条件、触发的动作

例如：当用户消费超过余额时，自动将余额归零并创建一条贷款信息

 <img src="数据库系统原理.assets/截屏2020-12-28 下午3.58.31.png" alt="截屏2020-12-28 下午3.58.31" style="zoom:50%;" />

> after update：更新后执行
>
> before update：更新后执行
>
> referencing new row：更新后的数据行
>
> referencing old row：更新前的数据行
>
> 行触发器： for each row：每行数据更新，都会触发
>
> 语句级触发器：当执行语句时触发



能够触发触发器操作的事件：数据的插入、修改、删除等；查询一般不会引起触发器执行



### 第十四章 事务

####  14.1事务的概念

事务：是数据库的执行单元，通常用来保证数据的一致性；用来保证在数据库操作执行的过程中，一些操作要么都执行，要么都不执行

一个事务中可以并行执行多个SQL更新语句

事务的产生是自动产生的

事务的提交是人为提交的

事务提交后是永久改变的，不会因为其他因素如宕机等而变化

事务的四个原则（属性）：

1.原子性：当前执行单元中的所有语句是一次性全部执行成功或者全部失败

2.一致性：在事务执行前后数据库都具有一致性

3.独立性：可以并发执行多个事务，多个事务之间独立，在提交之前，相互之间不影响

4.永久性：事务成功执行后，对数据库的更新是永久的，即使数据库发生错误等

例：

 <img src="数据库系统原理.assets/截屏2020-12-28 下午4.21.34.png" alt="截屏2020-12-28 下午4.21.34" style="zoom:50%;" />

没有明确的语句表示开启事务，只要对数据进行更新操作就会开启事务；以commit或rollback结束事务

commit：表示事务成功执行，将执行结果提交

rollback：回退到本事务执行前的状态

#### 14.2 事务状态

激活状态：开始执行事务

部分提交状态：部分语句已经执行完毕

失败状态：当前某一或几个语句执行错误，出现失败时应当放弃事务，进行回滚

放弃状态：放弃事务，进行回滚

提交状态：事务执行完毕，进行提交

 <img src="数据库系统原理.assets/截屏2020-12-28 下午4.32.33.png" alt="截屏2020-12-28 下午4.32.33" style="zoom:50%;" />

可恢复的管理机制：保留原始的数据，可以回滚到事务执行前

​	影子数据库：事务处于激活状态时，对数据库创建一个副本，对副本进行操作，操作完成并提交后，改变数据指针指向

​	 <img src="数据库系统原理.assets/截屏2020-12-28 下午4.36.22.png" alt="截屏2020-12-28 下午4.36.22" style="zoom:50%;" />

​	前提：1.有足够空间可以存放原数据和新数据，且不论指针指向哪个存储区域，磁盘无错误

​				2.文本编辑工具：对数据进行读写

​				3.由于涉及到数据指针的移动，所以影子数据库不适合并发事务

#### 14.3 并发操作

数据库本身是多用户、多事务的并发系统

事务并发执行：

​	可以提高系统执行的效率、设备的利用率

​	减少平均等待时间（如短事务优先执行）

​	有可能产生不一致：一个事务执行过程中又执行其他事务

并发控制：由数据库本身控制，保证并发的调度和数据一致性

调度：一个调度包含一个或多个事务的全部指令，调度必须保证所有事务的所有指令都被执行到

调度过程中还要保持属于同一个事务的指令的执行次序不变，每个事务要么所有指令执行成功要么全部执行失败

例：

<img src="数据库系统原理.assets/截屏2020-12-28 下午4.52.34.png" alt="截屏2020-12-28 下午4.52.34" style="zoom:50%;" /> <img src="数据库系统原理.assets/截屏2020-12-28 下午4.53.15.png" alt="截屏2020-12-28 下午4.53.15" style="zoom:50%;" />

> 串行调度：一个事务全部执行完再执行其他事务

 <img src="数据库系统原理.assets/截屏2020-12-28 下午4.57.28.png" alt="截屏2020-12-28 下午4.57.28" style="zoom:67%;" />

以上三种正确

 <img src="数据库系统原理.assets/截屏2020-12-28 下午4.58.26.png" alt="截屏2020-12-28 下午4.58.26" style="zoom:50%;" />

该调度错误

事务调度由专门的并发控制器控制



#### 14.4 可串行化

对数据库的操作简化为read和write

1.冲突可串行化：

​	冲突的指令：在T_i和T_j两个事务中有li和lj是对同一数据项Q的读和写操作，如果均为读操作，则li和lj是不冲突的，否则li和lj是冲突的

​	不冲突的指令是可以调换顺序的，交换后，并行化的调度转化为串行化的调度，称为冲突可串行化

​	如果调度S经过一些列不冲突的指令之间的调换得到S‘，称S是冲突可串行化的，S和S’是冲突等价的

​	冲突的指令不可以调换次序

2.视图可串行化：

​	1.在两个调度中，对于数据项Q，如果Ti中有对Q初始值的读，则进行等价之后，Ti也应该读出Q的初始值

​	2.Ti读Q之前，有其他事务对Q进行了写操作，则进行等价后，Ti读出的数据也应该是修改后的

​	3.如果对Q的写操作位于S中的最后，则进行等价后，对Q的写也应该在最后

 <img src="数据库系统原理.assets/截屏2020-12-28 下午9.52.21.png" alt="截屏2020-12-28 下午9.52.21" style="zoom:50%;" />

因此可串行化为T3 T4 T6的顺序执行

#### 14.5 串行化的检测

检测方式：如果在调度中有一系列的调度T1……Tn，画出优先图：各个事务之间对数据项操作的先后顺序

<img src="数据库系统原理.assets/截屏2020-12-28 下午9.57.26.png" alt="截屏2020-12-28 下午9.57.26" style="zoom:67%;" /> 

如果Ti与Tj是冲突可串行化调度的，则Ti与Tj之间无有向环路

例：

 <img src="数据库系统原理.assets/截屏2020-12-28 下午9.58.32.png" alt="截屏2020-12-28 下午9.58.32" style="zoom:67%;" />

优先图如下（T5对V W的操作不影响）：

 <img src="数据库系统原理.assets/截屏2020-12-28 下午10.01.08.png" alt="截屏2020-12-28 下午10.01.08" style="zoom:67%;" />

#### 14.6 可恢复调度

如果T8在writeA后T9 readA，之后提交，但后续T8回滚，则该调度是不可恢复调度

 <img src="数据库系统原理.assets/截屏2020-12-28 下午10.05.52.png" alt="截屏2020-12-28 下午10.05.52" style="zoom:67%;" />

级联回滚：一个事务的回滚导致多个其他事务进行回滚操作，如下，如果T10回滚，则T11和T12也应该回滚

 <img src="数据库系统原理.assets/截屏2020-12-28 下午10.08.49.png" alt="截屏2020-12-28 下午10.08.49" style="zoom:50%;" />

级联回滚开销大，因此调度最好不要级联的。如果Tj读取了Ti写的数据，则Ti应该在Tj之前提交

并发控制策略：通过一系列实现判别，来保证当前调度是可串行化的，并且不需要通过事后的优先图来验证。需要额外的空间和开销

使用优先图进行判别的作用：检验并发控制策略是否正确

